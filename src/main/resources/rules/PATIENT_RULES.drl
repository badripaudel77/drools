package rules;

import com.app.tracker.models.Patient;
import com.app.tracker.models.Category;
import java.util.List;

import java.lang.Thread; // Just for testing purposes.

global com.app.tracker.services.PatientService patientService;

rule "Speak about the diseases"
dialect "mvel"
salience 100

/**
 *     $patient1 : Patient( this.patientAddress.country == "Nepal")
 *     $patient2 : Patient( this.patientAddress.country == "India")
 *
 *     Writing => $patient1 : Patient( this.patientAddress.country == "Nepal" || this.patientAddress.country == "India") is better since for $patient1, $patient2 is also scanned (i.e then part is executed).
 *     Still the best is to splitting it into two different rules so that they become atomic.
 *     (write code and see the sout logs)
 */
  when
     /*
      * Avoid this if possible
      *     $patient1 : Patient( this.patientAddress.country == "Nepal")
      *     $patient2 : Patient( this.patientAddress.country == "India")
      *
      * Instead write :
      *  $patient1 : Patient( this.patientAddress.country == "Nepal" || this.patientAddress.country == "India")
      */

       $patient1 : Patient( this!.patientAddress!.country == "Nepal") // ! = != (null safe)
       $patient2 : Patient( this.patientAddress.country == "India")

      // $patient : Patient( this.patientAddress.country == "Nepal" || this.patientAddress.country == "India")

then
      // WARN:: Just for testing purposes.
      Thread.sleep(5000);
      System.out.println("Patient from " + $patient1.patientAddress.country + " with name " + $patient1.patientName);
      System.out.println("Patient from " + $patient2.patientAddress.country + " with name " + $patient2.patientName);

      // These insert statements will trigger any rules that are dependent on Category fact.
      insert(new Category(100, "NATIONAL", $patient1))
      insert(new Category(100, "SAARC", $patient2))
     // System.out.println("Patient from " + $patient.patientAddress.country + " with name " + $patient.patientName);
end

rule "Check if we have Patient from SAARC countries"
dialect "mvel"

no-loop // see comment below for why to use this
// rule attribute are evaluated after condition so that they can use the values defined in condtion part like $is in this case.
// Since enabled is evaulated after when, we'have access to the $p, $c
//enabled ($c.categoryName == "SAARC")
enabled ($isFromSAARC != null)
when
    $p : Patient(patientAddress.country.toLowerCase() == "INDIA".toLowerCase()) // for simplicity only India is checked
    $c : Category(patient == $p, $isFromSAARC : categoryName == "SAARC")

then
    $c.setCategoryName("SAARC");
    /**
     * will trigger to re-evaluate this rule again and again as it is updated unless no-loop attribute is used.
     * Solution : use no-loop attribute
     */
    update($c);
    System.out.println("You'll get some discount >>> " + $p.patientName + " >> " + $c.categoryName);
end

/**
 * Grouping patients using collect keyword
 * The "collect" keyword is used to find all the elements that match a specific condition
 * and group them into a collection. Later on, this collection can be assigned to a
 * variable or submitted to further conditions
 */

rule "Group Patients and Store them"
dialect "mvel"

when
    // include size > 0 as a guard otherwise it would still fire and return empty list even if no elements are present.
    $allPatients : List( size > 0) from collect(Patient())
then
    System.out.println("Total Patients (using simple collect() ) >>> " + $allPatients.size());
end

/**
 * Use accumulate function to count the number of Patients
 */

rule "Use of Accumulate & aggregate functions"
dialect "mvel"
// enabled false;
when
        // Accumulate all the Patient meeting the match conditions and store other aggregate functions' results in variables
        // Look, here we have omitted return type as we're storing results inside of the variables
        // Otherwise, we could write as
        /**
         *    $res :  Number( intValue > 0) from accumulate ( conditons, aggregate_fucntion);
         *    eg :
         *    $tot : Number() from accumulate(
         *                 Patient(patientId != 01, $pId: patientId),
         *                 count($pId)
         *         )
         */
         accumulate(
                Patient(patientId != 01, $pId: patientId),
                $sumOfIds : sum($pId),
                $maxId : max($pId),
                $minId : min($pId),
                $totalPatients : count($pId)
        )
then
    System.out.println("Sum of IDS >>> " + $sumOfIds + " Max ID >>> " + $maxId + " Min ID >>> " + $minId + " Total Patients >>> " + $totalPatients);
end

rule "Use of Accumulate & aggregate functions : collectList()"
dialect "mvel"
when
        $listOfPatients : List( size > 3) from accumulate(
            $patient : Patient(patientId != 01, $pId: patientId),
                     collectList($patient)
        )
then
        patientService.logTheMessage();
        System.out.println(" Total, using collectList(), count = " + $listOfPatients.size());
end

/**
 * Usage of forall keyword
 */
rule "Check if all the patients have at an Address"
dialect "mvel"

when
    exists(Patient()) // Must check it to avoid fail case where is nothing in the memory. Ensure there is at least a Patient fact in the session.
    // Ensure for all Patient in the memory, they have address as not null i.e must have an address.
    forall(
            // For all Patient(), it must satisfy the Patient(this.patientAddress == null) condition.
            Patient() // select all the Patient first
            Patient(this.patientAddress == null) // if this satisfies for all the Patient, then will be evaluated.
        )
then
    System.out.println("Yes all patients have address.");
end